#pragma once

#include "iterator.hpp"
#include "container_defines.hpp"
#include <memory>
#include <iostream>
#include "swap.hpp"
#include "iterator_traits.hpp"

namespace ft {
	template <class T>
	void	swap(T& first, T& sec);
	template <class T, class Alloc = std::allocator<T> >
	class vector {
	public:
		typedef		typename Alloc::pointer			iterator;
		typedef		typename Alloc::reference		reference;
		typedef		typename Alloc::const_pointer	const_iterator;
		typedef		typename Alloc::const_reference	const_reference;
		typedef		typename Alloc::difference_type	difference_type;
		typedef		typename Alloc::size_type		size_type;
		typedef		T								value_type;
		typedef		ft::reverse_iterator<iterator, value_type, reference, difference_type>	reverse_iterator;
		typedef		ft::reverse_iterator<const_iterator, value_type, const_reference, difference_type>	const_reverse_iterator;
		typedef		ft::input_iterator<iterator, T>				InputIterator;
		typedef		typename ft::random_access_iterator_tag		iterator_category;
	private:
		iterator			_start;
		iterator			_finish;
		iterator			_endofstorage;
		Alloc				allocator;
		void	fill_n(size_type n, const T& val) {
			for (size_type i = 0; i < n; i++)
				allocator.construct(_start + i, val);
			};
		void	fill_n_from(iterator from, size_type n, const T& val) {
			for (size_type i = 0; i < n; i++)
				allocator.construct(from + i, val);
		}
		void	destroy(iterator element) {
			allocator.destroy(element);
		}
		iterator	copy_range(iterator beg, iterator dest, size_type alloc_size) {
			iterator	new_data = allocator.allocate(alloc_size);
			iterator	c_nd = new_data;
			while (beg != dest && beg < dest + 1 && (beg != 0 || dest != 0)) {
				allocator.construct(c_nd++, *(beg++));
			}
			return new_data;
		};

		///moves range from higher position to lower position without allocation
		iterator	move_range(iterator position, iterator beg, iterator dest) {
			iterator n_it = position;
			for (iterator it = beg; it != dest + 1;) {
				allocator.construct(n_it++, *it);
				allocator.destroy(it++);
			}
			return n_it;
		}

		///moves range from lower position to higher position without allocation
		iterator	r_move_range(iterator position, iterator beg, iterator dest) {
			iterator n_it = position;
			for (iterator it = dest; it != beg - 1;) {
				allocator.construct(n_it--, *it);
				allocator.destroy(it--);
			}
			return n_it;
		}

	public:
		vector() {
			_start = 0;
			_finish = 0;
			_endofstorage = 0;
		}
		vector(size_type n, const T& val = T()) {
			_start = allocator.allocate(n);
			fill_n(n, val);
			_finish = _start + n;
			_endofstorage = _finish;
		}
		vector(iterator first, iterator last) {
			size_type	range = last - first;
			_start = allocator.allocate(ft::difference<iterator, difference_type>(first, last));
			iterator	pos = _start;
			iterator	val = first;
			for (size_type i = 0; i < range; i++)
				allocator.construct(pos++, *(val++));
			_finish = _start + range;
			_endofstorage = _finish;
		}
		vector(ft::vector<T, Alloc>& ori) {
			size_type	range = ori.size();
			_start = allocator.allocate(range);
			iterator	pos = _start;
			iterator	val = ori.begin();
			for (size_type i = 0; i < range; i++)
				allocator.construct(pos++, *(val++));
			_finish = _start + range;
			_endofstorage = _finish;
		}

		vector&	operator=(const vector& ori) {
			clear();
			size_type	range = ori.size();
			_start = allocator.allocate(range);
			iterator	pos = _start;
			const_iterator	val = ori.begin();
			for (size_type i = 0; i < range; i++)
				allocator.construct(pos++, *(val++));
			_finish = _start + range;
			_endofstorage = _finish;
			return *this;
		}

		template <class InputIterator>
		void assign (InputIterator first, InputIterator last) {
			clear();
			_start = copy_range(first, last, last - first);
			_finish = _start + (last - first);
			_endofstorage = _finish + 1;
		}

		void assign (size_type n, const value_type& val) {
			clear();
			_start = allocator.allocate(n);
			iterator pos = _start;
			for (size_type i = 0; i < n; i++)
				allocator.construct(pos++, val);
			_finish = _start + n;
			_endofstorage = _finish;
		}



		void clear() {
			for (iterator i = begin(); i != end(); i++)
				allocator.destroy(i);
			allocator.deallocate(_start, size());
			_start = NULL;
			_finish = NULL;
			_endofstorage = NULL;
		}
		///	CAPACITY:
		size_type	size() const {		return (_finish - _start); };
		size_type	max_size() const {	return allocator.max_size(); };
		bool		empty() const {	return !size(); };
		size_type	capacity() const { return _endofstorage - _start; };

		void		reserve(size_type n) {
			if (n <= capacity())
				return;
			iterator	new_storage = copy_range(_start, _finish - 1, n);
			size_type	temp_size = size();
			iterator	next = _start;
			while (next != _finish)
				destroy(next++);
			allocator.deallocate(_start, capacity());
			_start = new_storage;
			_finish = _start + temp_size;
			_endofstorage = _start + n;
		};

		//TODO: LEAKS
		void resize (size_type n, T val = T()) {
			size_type	old_s = size();
			if (n > size()) {
				iterator new_storage = copy_range(_start, _finish, n);
				for (iterator it = _start; it != _finish; it++)
					destroy(it);
				allocator.deallocate(_start, size());
				_start = new_storage;
				_finish = _start + old_s;
				for (size_type i = old_s; i < n; i++)
					allocator.construct(_finish++, val);
				_finish = _start + n;
				_endofstorage = _finish;
			} else if (n < size()) {
				iterator new_storage = copy_range(_start, _start + n, n);
				for (iterator it = _start; it != _finish; it++)
					destroy(it);
				allocator.deallocate(_start, size());
				_start = new_storage;
				_finish = _start + n;
				_endofstorage = _finish;
			}
		}
		///	ITERATORS:
		iterator	begin() {			return _start; };
		const_iterator	begin() const {	return _start; };
		iterator	end() {				return _finish; };
		const_iterator	end() const {	return _finish; };
		reverse_iterator	rbegin() { return reverse_iterator(_finish); };
		reverse_iterator	rend() { return reverse_iterator(_start); };

		const_reverse_iterator	rbegin() const { return const_reverse_iterator(_finish); };
		const_reverse_iterator	rend() const { return const_reverse_iterator(_start); };
		/// ELEMENT ACCESS:
		reference			operator[](size_type n) {
			return _start[n];
		}
		reference			at(size_type n) {
			if (n >= size())
				throw std::out_of_range("vector");
			else
				return _start[n];
		};

		reference			front() {
			return *begin();
		}
		reference			back() {
			return *(end() - 1);
		}

		const_reference			front() const {
			return *begin();
		}
		const_reference			back() const {
			return *(end() - 1);
		}

		const_reference			operator[](size_type n) const{
			return _start[n];
		}
		const_reference			at(size_type n) const{
			if (n >= size())
				throw std::out_of_range("vector");
			else
				return _start[n];
		};
		///MODIFIERS: assign, push_back, pop_back, insert, erase, swap, clear
		void	pop_back() {
			if (empty())
				return;
			--_finish;
			destroy(_finish);
		}

		iterator	erase(iterator position) {
			if (position == _finish - 1) {
				allocator.destroy(position);
				_finish--;
			} else {
				allocator.destroy(position);
				_finish = move_range(position, position + 1, _finish - 1);
			}
			return _finish - 1;
		}

		iterator	erase(iterator beg, iterator dest) {
			iterator ret = dest + 1;
			if (beg == dest)
				ret = dest;
			else if (dest == _finish) {
				for (iterator it = beg; it != dest; it++)
					allocator.destroy(it);
				_finish = beg;
				ret = _finish;
			} else {
				for (iterator it = beg; it != dest; it++)
					allocator.destroy(it);
				_finish = move_range(beg, dest, _finish - 1);
			}
			return ret;
		}

		void		push_back (const value_type& val) {
			if (capacity() < size() + 1) {
				size_type	old_size = size();
				size_type	new_capa = capacity() + capacity() * 0.5 + 1;
				iterator	temp = copy_range(_start, _finish, new_capa);
				allocator.deallocate(_start, old_size);
				_start = temp;
				_finish = _start + old_size + 1;
				allocator.construct(_finish - 1,  val);
				_endofstorage = _start + new_capa;
			} else {
				_finish++;
				allocator.construct(_finish - 1,  val);
			}
		}

		iterator	insert (iterator position, const value_type& val) {
			if (capacity() < size() + 1) {
				long		new_pos = position - _start;
				size_type	temp_size = size();
				size_type	new_capacity = capacity() * 2;
				iterator temp = copy_range(_start, _finish, new_capacity);
				allocator.deallocate(_start, temp_size);
				_start = temp;
				_finish = _start + temp_size;
				_endofstorage = _start + new_capacity;
				position = _start + new_pos;
			}
			iterator	next = _finish - 1;
			while (next != position - 1) {
				allocator.construct(next + 1, *next);
				destroy(next--);
			}
			allocator.construct(position, val);
			_finish++;
			return position;
		}

		void	insert (iterator position, size_type n, const value_type& val) {
			if (capacity() < size() + n) {
				long		new_pos = position - _start;
				size_type	temp_size = size();
				size_type	new_capacity = capacity() + n + 1;
				iterator temp = copy_range(_start, _finish, capacity() + n + 1);
				allocator.deallocate(_start, temp_size);
				_start = temp;
				_finish = _start + temp_size;
				_endofstorage = _start + new_capacity;
				position = _start + new_pos;
			}
			iterator	next = _finish - 1;
			while (next != position - 1) {
				allocator.construct(next + n, *next);
				destroy(next);
				next--;
			}
			next = position;
			for (size_type i = 0; i < n; i++)
				allocator.construct(next++, val);
			_finish += n;
		}
//		template <class InputIterator>
//		void	insert (iterator position, InputIterator first, InputIterator last) {
//			if (capacity() >= size() + (last - first)) {
//				r_move_range(_finish + (last - first), position, _finish - 1);
//				iterator old_pos = position;
//				position += last - first;
//				_finish += last - first;
//				for (iterator it = first; old_pos != position; it++)
//					allocator.construct(old_pos++, *it);
//			} else {
//				size_type old_size = size();
//				size_type front = position - _start;
//				size_type back = _finish - position;
//				iterator  old_start = _start;
//				size_type new_size = old_size + (last - first) * 2;
//				iterator  new_al = copy_range(_start, position - 1, new_size);
//				_start =  new_al;
//				iterator  n_it = _start + front;
//				for (iterator it = first; it != last + 1; it++) //copy new range into vector
//					allocator.construct(n_it++, *it);
//				iterator  cp_pos = position;
//				for (; n_it != _start + front + last - first + back; n_it++) //copy old back part to new vector
//					allocator.construct(n_it, cp_pos++);
//				for (iterator it = old_start; it != _finish; it++) //destroy and deallocate old vector
//					destroy(it);
//				allocator.deallocate(old_start, old_size);
//			}
//		}
		template <class InputIterator>
		void	insert (iterator position, InputIterator first, InputIterator last) {
			size_type diff = last - first;
			if (capacity() >= size() + diff) {
				r_move_range(_finish + (last - first), position, _finish - 1);
				iterator old_pos = position;
				position += last - first;
				_finish += last - first;
				for (iterator it = first; old_pos != position; it++)
					allocator.construct(old_pos++, *it);
			} else {
				size_type old_size = size();
				size_type front = position - _start;
				size_type back = _finish - position;
				iterator  old_start = _start;
				size_type new_size = old_size + (last - first) * 2;
				iterator  new_al = copy_range(_start, position - 1, new_size);
				_start =  new_al;
				iterator  n_it = _start + front;
				for (iterator it = first; it != last; it++) //copy new range into vector
					allocator.construct(n_it++, *it);
				iterator  cp_pos = position;
//				diff = last - first;
				for (; n_it != (_start + front + diff + back); n_it++) //copy old back part to new vector
					allocator.construct(n_it, *(cp_pos++));
				for (iterator it = old_start; it != _finish; it++) //destroy and deallocate old vector
					destroy(it);
				allocator.deallocate(old_start, old_size);
				_finish = _start + front + diff + back;
				_endofstorage = _start + new_size;
			}
		}

		void	swap(vector<T, Alloc>& sec) {
			ft::swap(_start, sec._start);
			ft::swap(_finish, sec._finish);
			ft::swap(_endofstorage, sec._endofstorage);
		}
//        void assign(size_type n, const value_type& val)
//        {
//            if (n <= capacity()) {
//                const size_type s = size();
//                ft::fill_n(begin_, ft::min(n, s), val);
//                if (n > s)
//                    construct_from_end_(n - s, val);
//                else
//                    destroy_from_end_(begin_ + n);
//            } else {
//                vector tmp(n, val);
//                swap(tmp);
//            }
//        }
//
//        template <class InputIterator>
//        void assign(
//                InputIterator first, InputIterator last,
//                typename ft::enable_if<!ft::is_integral<InputIterator>::value, InputIterator>::type* = 0)
//        {
//            assign_range_(first, last, ft::iterator_category(first));
//        }


	};

#include "compare.hpp"

	template <class T, class Alloc>
	bool operator==(const vector<T, Alloc>& first, const vector<T, Alloc>& sec) {
		if (first.size() != sec.size())
			return false;
		return ft::equal(first.begin(), first.end(), sec.begin());
	}

	template <class T, class Alloc>
	bool operator!=(const vector<T, Alloc>& first, const vector<T, Alloc>& sec) {
		return !(first == sec);
	}

	template <class T, class Alloc>
	bool operator<(const vector<T, Alloc>& first, const vector<T, Alloc>& sec) {
		return ft::lexicographical_compare(first.begin(), first.end(), sec.begin(), sec.end());
	}

	template <class T, class Alloc>
	bool operator>(const vector<T, Alloc>& first, const vector<T, Alloc>& sec) {
		return ft::lexicographical_compare(sec.begin(), sec.end(), first.begin(), first.end());
	}

	template <class T, class Alloc>
	bool operator<=(const vector<T, Alloc>& first, const vector<T, Alloc>& sec) {
		return ! (first > sec);
	}

	template <class T, class Alloc>
	bool operator>=(const vector<T, Alloc>& first, const vector<T, Alloc>& sec) {
		return ! (first < sec);
	}

	template <class T, class Alloc>
	void	swap(vector<T, Alloc>& first, vector<T, Alloc>& sec) {
		first.swap(sec);
	};

}
